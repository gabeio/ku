## Paged Memory Management
- a job's address space is divided into equal size pieces called *pages*
- physical memory is divided into equal size pieces called *page frames* or *blocks*
- user pages remain logically contiguous when loaded into memory; physical locations do not have to be contiguous.

### mapping function
address space >>> physical memory

requires page map tables (PMT) to keep track of the physical location of each page in memory
ex: page size = 1000 bytes; job needs 2400 bytes; this job would end up on 3 pages

internal fragmentation
best case = 0
worse case = page size -1 byte
average case = page size / 2

every address generated by the cpu is divided into 2 parts
1. page # (p)
2. displacement or offset (d)

large page size = more fragmentation
small page size = more memory usage via pmt

Sharing Code (compilers, text editors, assemblers, ...)
in order for code to be shareable it must be reentrant (pure) - that is it never alters itself.

### protection
include a protection field in the PMT (access control)

### paging advantages
- eliminates external frag
- mem assigned does not have to be contiguous
- makes it possible to share code

### disadvantages of paging
- internal frag
- mapping hardware slows down the speed of the system
- mem lost to storing the tables (pmt, mbt) and the cpu time is spent maintaining the tables
- job's size is limited to size of available memory
- memory may contain information that is never used

**next week is the midterm**
